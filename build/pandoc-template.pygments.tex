\documentclass[fancyhdr,bookmark]{ctexbook}
\setCJKmainfont{SimSun}
\setmainfont{Georgia} 	% 設定英文字型
\setromanfont{Georgia} 	% 字型
\setmonofont{Latin Modern Mono}

% pandoc版本大于1.15时需要\tightlist
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\usepackage{tikz} % Required for drawing custom shapes
\usepackage[yyyymmdd,hhmmss]{datetime}
\ctexset{today=small}
\usepackage{geometry} 		% 設定邊界
\geometry{
  top=1in,
  inner=1in,
  outer=1in,
  bottom=1in,
  headheight=3ex,
  headsep=2ex
}


\usepackage{xcolor}
\definecolor{ocre}{RGB}{243,102,25} % Define the orange color used for highlighting throughout the book

%\usepackage[x11names,svgnames,dvipsnames]{xcolor}
\usepackage{listings}
\lstset{
	%numbers=left,
	%numberstyle=\tiny,
	basicstyle=\small\ttfamily,
	keywordstyle=\color[rgb]{0.13,0.29,0.53}\textbf,
	commentstyle=\color[rgb]{0.56,0.35,0.01}\textit,
	identifierstyle=\color[rgb]{0.00,0.00,0.00},
	stringstyle=\color[rgb]{0.31,0.60,0.02},
	frame=shadowbox,
	rulesepcolor=\color{red!20!green!20!blue!20},
	backgroundcolor=\color[rgb]{0.97,0.97,0.97},
	tabsize=4,
	breaklines=tr,
	showstringspaces=false,
}
\renewcommand{\lstlistingname}{代码}

%\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
%\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{{#1}}}
%\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
%\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
%\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
%\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
%\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
%\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
%\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{{#1}}}
%\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{{#1}}}
%\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
%\newcommand{\RegionMarkerTok}[1]{{#1}}
%\newcommand{\ErrorTok}[1]{\textbf{{#1}}}
%\newcommand{\NormalTok}[1]{{#1}}



\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={An He},
            pdftitle={用Markdown+Pandoc+XeLaTeX写作},
            colorlinks=true,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}

\usepackage{longtable,booktabs}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}


\title{用Markdown+Pandoc+XeLaTeX写作}
\author{An He}
\date{\today}
\usepackage{cleveref}

\usepackage{fancyhdr}
%\usepackage{lastpage}
\pagestyle{fancy}


\begin{document}
\frontmatter
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\begingroup
\thispagestyle{empty}
\begin{tikzpicture}[remember picture,overlay]
\node[inner sep=0pt] (background) at (current page.center) {\includegraphics[width=\paperwidth]{Pictures/background}};
\draw (current page.center) node [fill=ocre!30!white,fill opacity=0.6,text opacity=1,inner sep=1cm]
{\Huge\centering\bfseries\sffamily\parbox[c][][t]{\paperwidth}
{\centering 用Markdown+Pandoc+XeLaTeX写作\\[13pt] % Book title
{\huge An He} % Author name
}};
\end{tikzpicture}
\vfill
\endgroup
\addcontentsline{toc}{chapter}{封面}

%----------------------------------------------------------------------------------------
%	COPYRIGHT PAGE
%----------------------------------------------------------------------------------------
\newpage
~\vfill
\thispagestyle{empty}

\noindent Copyright \copyright\ \the\year\  An He\\ % Copyright notice

\noindent \textsc{Published by \LaTeX}\\ % Publisher
\noindent \textsc{https://github.com/annProg/pandoc-template}\\ % URL

\noindent Licensed under the Creative Commons Attribution-NonCommercial 3.0 Unported License (the ``License''). You may not use this file except in compliance with the License. You may obtain a copy of the License at \url{http://creativecommons.org/licenses/by-nc/3.0}. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \textsc{``as is'' basis, without warranties or conditions of any kind}, either express or implied. See the License for the specific language governing permissions and limitations under the License.\\ % License information

\noindent \textit{最后编译日期, \today\ \currenttime } % Printing/edition date


    
\chapter*{前言}
\addcontentsline{toc}{chapter}{前言}
\LaTeX~可以排版格式精美的书籍，但是学习成本较高，使用不便；
Markdown是一种简单易学的标记语言。如果能结合两者的优点，使用Markdown
来写作，然后通过程序转换为latex源码，再编译为PDF，那将是一件美妙的事情。
幸运的是，已经有工具很好的实现了支持这一功能，那就是Pandoc。

Pandoc是由 John MacFarlane 教授开发的标记语言转换工具，实现了数十种标
记语言之间的转换。Pandoc还扩展了Markdown语法，比如标题表格等的ID属性，
脚注等，并且可以直接嵌入LaTeX代码，这样在Markdown中就可以实现输入数学
公式，交叉引用等功能。Pandoc还支持自定义转换模板，通过命令\lstinline!pandoc -D latex!可以输出默认的LaTeX模板，以此模板为基础，可以定制自己的模板。

本工具定义了一种Markdown源码组织规范，提供了一个转换脚本，用来更方便的
使用Pandoc将Markdown转换为PDF。另外还定义了一套LaTeX书籍模板，用来生成
中文书籍。用户也可以在自己的工作目录修改此模板，并通过修改配置来引用自己
的模板。


{
\hypersetup{linkcolor=black}
\setcounter{tocdepth}{2}
\tableofcontents
\addcontentsline{toc}{chapter}{目录}
}
\listoftables
\addcontentsline{toc}{chapter}{表格列表}
\listoffigures
\addcontentsline{toc}{chapter}{插图列表}



\mainmatter
    % 在此命令之后的页码为阿拉伯数字
    % 以下为正文
\chapter{使用说明}\label{ux4f7fux7528ux8bf4ux660e}

\section{安装步骤}\label{ux5b89ux88c5ux6b65ux9aa4}

首先克隆代码库

\begin{lstlisting}
git clone https://github.com/annProg/pandoc-template
\end{lstlisting}

然后将pandoc-template目录加入环境变量

建立工作目录

\begin{lstlisting}
mkdir workdir
cd workdir
bookgen.sh init # 初始化工作环境
\end{lstlisting}

目录结构说明

\begin{lstlisting}
.
├── book                                    # 书籍模板，暂未用到
│   ├── book-template.latex
│   └── pm-template.latex
├── bookgen.sh                              # 转换脚本
├── build                                   # 电子书构建目录
├── config.default                          # pandoc默认转换配置
├── html5                                   # html5电子书模板
├── README.md
├── resume                                  # 简历模板
├── src                                     # Markdown源码目录
│   └── images                              # 源码涉及插图目录
└── zh-ctex                                 # ctexbook模板目录
    ├── Pictures                            # 模板引用的图片资源
\end{lstlisting}

\section{使用规范}\label{ux4f7fux7528ux89c4ux8303}

\subsection{源码命名规范}\label{ux6e90ux7801ux547dux540dux89c4ux8303}

脚本中使用\lstinline!ls src/*.md!列出所有的Markdown源码，要保证顺序正确，才能生成正确的LaTeX源码。
因此，要求Markdown源码文件命名能够被ls以正确的顺序列出。例如，有少于十个的Markdown文件，
可以使用0\textasciitilde{}9为前缀：

\begin{lstlisting}
$ tree src/
src/
├── 0-title.md
├── 1-intro.md
├── 2-pandoc-markdown.md
├── 3-template.md
└── images
\end{lstlisting}

如果Markdown文件数多于10个，则需要在前缀为个位数的前面补0，与最大前缀数字位数保持一致，例如
最后一个Markdown文件为\lstinline!99-markdown.md!，那么个位数应形如
\lstinline!01-first.md!。

\subsection{编码规范}\label{ux7f16ux7801ux89c4ux8303}

Markdown源码文件需要使用UTF-8编码。以Notepad++为例，依次选择\textbf{格式，以UTF-8无BOM格式编码}
即可正确设置编码。

\subsection{注意事项}\label{title:note}

Pandoc扩展的Markdown语法要求在标题前留出一个空行，因此按章节拆分的多个Markdown文件，开头需要
空一行，否则pandoc不能正确识别标题。

\section{模板变量说明}\label{ux6a21ux677fux53d8ux91cfux8bf4ux660e}

可以使用\href{http://www.ruanyifeng.com/blog/2016/07/yaml.html}{Yaml语言}
定义模板中的变量，建议第一个
Markdown文件专门用来定义变量，如代码\ref{code:template-var}所示。

\begin{lstlisting}[label=code:template-var, caption=code:template-var, float=htbp]
---
title: 用Markdown+Pandoc+XeLaTeX写作
author:          # 作者（数组）
  - An He
date: \today     # 日期
copyright: true  # 是否生成版权页
lof: true        # 是否生成插图列表页
lot: true        # 是否生成表格列表页
graphics: true   # 是否使用graphicx
homepage: https://github.com/annProg/pandoc-template
header-includes:
  - \usepackage{cleveref}
# preface用于生成前言
preface: '\LaTeX\ 可以排版格式精美的书籍，但是学习成本较高，使用不便；
 换行请在开头留出一个空格'
---
\end{lstlisting}

其中title，author，date 变量也可以通过以下形式来定义：

\begin{lstlisting}
% title
% author(s) (separated by semicolons)
% date
\end{lstlisting}

查看模板文件，可以获取所有变量（形如\lstinline!$var$!)。也可以通过修改模板来添加自定义的变量。

\section{转换命令}\label{ux8f6cux6362ux547dux4ee4}

pandoc-template目录加入环境变量后可以直接调用\lstinline!bookgen.sh!：

\begin{lstlisting}
bookgen.sh init  # 初始化工作环境
bookgen.sh pdf   # 生成pdf电子书
bookgen.sh html  # 生成html电子书
bookgen.sh pdf d # 调试模式，只使用一个代码高亮风格， html电子书也支持调试模式
\end{lstlisting}

\chapter{Pandoc
Markdown语法简介}\label{pandoc-markdownux8bedux6cd5ux7b80ux4ecb}

Pandoc 的目标与原始Markdown 的最初目标有着方向性的不同。在Markdown
原本的设计中， HTML 是其主要输出对象；然而Pandoc
则是针对多种输出格式而设计。因此，虽然Pandoc 同样也允许直接嵌入HTML
标签，但并不鼓励这样的作法，取而代之的是Pandoc 提供了许多 非HTML
的方式，来让使用者输入像是定义列表、表格、数学公式以及脚注等诸如此类的重
要文件元素。

Pandoc
Markdown语法介绍可以在\href{http://www.pandoc.org/MANUAL.html\#pandocs-markdown}{Pandoc主页}
找到。以下翻译大部分部分摘自\href{http://pages.tzengyuxio.me/pandoc/}{tzengyuxiao的翻译}，
在此向译者表示感谢。

\section{段落}\label{ux6bb5ux843d}

一个段落指的是一行以上的文字，跟在一行以上的空白行之后。换行字元会被当作是空白处
理，因此你可以依自己喜好排列段落文字。如果你需要强制换行，在行尾放上两个以上的空
白字元即可。

\subsubsection{Extension:
escaped\_line\_breaks}\label{extension-escaped_line_breaks}

一个反斜线后跟着一个换行字元，同样也有强制换行的效果。这也是在表格单元格中添加换
行的唯一形式。

\section{标题}\label{ux6807ux9898}

有两种不同形式的标题语法，Setext
以及Atx。Setext风格的标题是由一行文字底下接着一
行=符号（用于一阶标题）或-符号（用于二阶标题）所构成；Atx风格的标题是由一到六个\#符
号以及一行文字所组成，你可以在文字后面加上任意数量的\#符号。由行首起算的\#符号数量决
定了标题的阶层，如代码\ref{code:markdownTitle}所示。

\begin{lstlisting}[caption=测试, label=code:markdownTitle, float=htbp]
Setext A level-one header
==================

Setext A level-two header
------------------

# Atx level-one

## Atx level-two

### Atx  level-three
\end{lstlisting}

\subsubsection{Extension:
blank\_before\_header}\label{extension-blank_before_header}

原始markdown语法在标题之前并不需要预留空白行。Pandoc则需要（除非标题位于文件最开始的
地方）。这是因为以\#符号开头的情况在一般文字段落中相当常见，这会导致非预期的标题。例如：

\begin{lstlisting}
I like several of their flavors of ice cream:
#22, for example, and #5.
\end{lstlisting}

这也是前一章所述注意事项\ref{title:note}的原因。

\subsection{标题标识符}\label{ux6807ux9898ux6807ux8bc6ux7b26}

\subsubsection{Extension:
header\_attributes}\label{extension-header_attributes}

在标题文字所在行的行尾，可以使用以下语法为标题加上属性：

\begin{lstlisting}
{#identifier .class .class key=value key=value}
\end{lstlisting}

虽然这个语法也包含加入类别(class)以及键／值形式的属性(attribute)，
但目前只有标识符(identifier/ID)在输出时有实际作用（且只在部分格式
的输出，包括：HTML, LaTeX, ConTeXt, Textile, AsciiDoc）。举例来说，
下面是将标题加上foo标识符的几种方法：

\begin{lstlisting}
# My header {#foo}

## My header ##    {#foo}

My other header   {#foo}
---------------
\end{lstlisting}

（此语法与PHP Markdown Extra相容。）

具有unnumbered类别的标题将不会被编号，即使--number-sections的选项是开启
的。单一连字符号( -)等同于.unnumbered，且更适用于非英文文件中。因此，

\begin{lstlisting}
# My header {-}
\end{lstlisting}

与下面这行是等价的

\begin{lstlisting}
# My header {.unnumbered}
\end{lstlisting}

\section{引用}\label{ux5f15ux7528}

Markdown使用email的习惯来建立引用区块。一个引用区块可以由一或多个段落
或其他的区块元素（如列表或标题）组成，并且其行首均是由一个\textgreater{}符号加上一
个空白作为开头。（\textgreater{}符号不一定要位在该行最左边，但也不能缩进超过三个空白）。

\begin{lstlisting}
> This is a block quote. This
> paragraph has two lines.
>
> 1. This is a list inside a block quote.
> 2. Second item.
\end{lstlisting}

效果如下：

\begin{quote}
This is a block quote. This paragraph has two lines.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  This is a list inside a block quote.
\item
  Second item.
\end{enumerate}
\end{quote}

有一个「偷懒」的形式：你只需要在引用区块的第一行行首输入\textgreater{}即可，后面的
行首可以省略符号：

\begin{lstlisting}
> This is a block quote. This
paragraph has two lines.

> 1. This is a list inside a block quote.
2. Second item.
\end{lstlisting}

由于区块引用可包含其他区块元素，而区块引用本身也是区块元素，所以，引用
是可以嵌套入其他引用的。

\begin{lstlisting}
> This is a block quote.
>
>> A block quote within a block quote.
\end{lstlisting}

\subsubsection{Extension:
blank\_before\_blockquote}\label{extension-blank_before_blockquote}

原始markdown语法在区块引用之前并不需要预留空白行。Pandoc则需要（除非区
块引用位于文件最开始的地方）。这是因为以\textgreater{}符号开头的情况在一般文字段落中
相当常见（也许由于断行所致），这会导致非预期的格式。因此，除非是指定为
markdown\_strict格式，不然以下的语法在pandoc中将不会产生出嵌套区块引用：

\begin{lstlisting}
> This is a block quote.
>> Nested.
\end{lstlisting}

\section{代码}\label{ux4ee3ux7801}

\subsection{缩进式代码块}\label{ux7f29ux8fdbux5f0fux4ee3ux7801ux5757}

由四个空格或一个tab缩进的文本取做代码块，区块中的特殊字符、空格和换行都会
被保留，而缩进的空格和tab会在输出中移除，但在代码块中的空行不必缩进。

\begin{lstlisting}
#!/bin/bash

echo "Hello Markdown"
echo "Hello LaTeX"
\end{lstlisting}

\subsection{围栏式代码块}\label{ux56f4ux680fux5f0fux4ee3ux7801ux5757}

\subsubsection{Extension:
fenced\_code\_blocks}\label{extension-fenced_code_blocks}

除了标准的缩进式代码块之外，Pandoc还支持围栏式代码块，
代码块以三个或三个以
上的\textasciitilde{}符号行开始，以等于或多于开始行\textasciitilde{}个数符号行结束，
若是代码块中含有\textasciitilde{}，只需
使开始行和结束行中的\textasciitilde{}符号个数多于代码块中的即可

\begin{lstlisting}
~~~~~
~~~~
code here
~~~~
~~~~~~
\end{lstlisting}

\subsubsection{Extension:
backtick\_code\_blocks}\label{extension-backtick_code_blocks}

与\lstinline!fenced_code_blocks!相同，只不过使用反引号 ` 替换波浪线
\textasciitilde{} 而已

\subsubsection{Extension:
fenced\_code\_attributes}\label{extension-fenced_code_attributes}

\begin{lstlisting}[numbers=left, firstnumber=100, caption=围栏式代码块, label=code:fencedcode, float=htbp]
~~~~ {#code:mycode .haskell .numberLines startFrom="100" caption="围栏式代码块"}
qsort []     = []
qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++
               qsort (filter (>= x) xs)
~~~~~~
\end{lstlisting}

这里的mycode为ID，haskell与numberLines是类别，而startsFrom则是值为
100的属性。numberLines和startFrom配合使用可以显示代码行号，如果没有
指定startFrom，则默认从1开始。caption指定代码块标题，如果没有设置
caption，则默认使用ID作为caption。有些输出格式可以利用这些信息来作语法
高亮。目前使用到这些信息的输出格式仅有HTML与LaTeX。如果指定的输出格
式及语言类别有语法高亮支持，那么上面那段代码区块将会以高亮并带有行号
的方式呈现。

仅指定高亮语言时，可以简写为以下形式：

\begin{lstlisting}
~~~haskell
qsort [] = []
~~~
\end{lstlisting}

\section{行区块}\label{ux884cux533aux5757}

\subsubsection{Extension: line\_blocks}\label{extension-line_blocks}

行区块是一连串以竖线(
\textbar{})加上一个空格所构成的连续行。行与行间的区隔在
输出时将会以原样保留，行首的空白字元数目也一样会被保留；反之，这些行
将会以markdown的格式处理。这个语法在输入诗句或地址时很有帮助。

\begin{lstlisting}
| The limerick packs laughs anatomical
| In space that is quite economical.
|    But the good ones I've seen
|    So seldom are clean
| And the clean ones so seldom are comical

| 200 Main St.
| Berkeley, CA 94718
\end{lstlisting}

如果有需要的话，书写时也可以将完整一行拆成多行，但后续行必须以空白作为开始。
下面范例的前两行在输出时会被视为一整行：

\begin{lstlisting}
| The Right Honorable Most Venerable and Righteous Samuel L.
  Constable, Jr.
| 200 Main St.
| Berkeley, CA 94718
\end{lstlisting}

效果：

The limerick packs laughs anatomical\\
In space that is quite economical.\\
\hspace*{0.333em}\hspace*{0.333em}\hspace*{0.333em}But the good ones
I've seen\\
\hspace*{0.333em}\hspace*{0.333em}\hspace*{0.333em}So seldom are clean\\
And the clean ones so seldom are comical

200 Main St.\\
Berkeley, CA 94718

这是从reStructuredText借来的语法。

\section{列表}\label{ux5217ux8868}

\subsection{无序列表}\label{ux65e0ux5e8fux5217ux8868}

无序列表是以项目符号作列举的列表。每条项目都以项目符号( *, +或-)作开头。
下面是个简单的例子：

\begin{lstlisting}
* one
* two
* three
\end{lstlisting}

显示如下

\begin{itemize}
\tightlist
\item
  one
\item
  two
\item
  three
\end{itemize}

这会产生一个「紧凑」列表。如果你想要一个「宽松」列表，也就是说以段落格式处
理每个项目内的文字内容，那么只要在每个项目间加上空白行即可：

\begin{lstlisting}
* one

* two

* three
\end{lstlisting}

项目符号不能直接从行首最左边处输入，而必须以一至三个空白字元作缩进。项目符号
后必须跟着一个空白字元。

列表项目中的接续行，若与该项目的第一行文字对齐（在项目符号之后），看上去会较
为美观：

\begin{lstlisting}
* here is my first
  list item.
* and my second.
\end{lstlisting}

但markdown 也允许以下「偷懒」的格式：

\begin{lstlisting}
* here is my first
list item.
* and my second.
\end{lstlisting}

\subsubsection{四个空白规则}\label{ux56dbux4e2aux7a7aux767dux89c4ux5219}

一个列表项目可以包含多个段落以及其他区块等级的内容。然而，后续的段落必须接在空
白行之后，并且以四个空白或一个tab
作缩进。因此，如果项目里第一个段落与后面段落
对齐的话（也就是项目符号前置入两个空白），看上去会比较整齐美观：

\begin{lstlisting}
  * First paragraph.

    Continued.

  * Second paragraph. With a code block, which must be indented
    eight spaces:

        { code }
\end{lstlisting}

列表项目也可以包含其他列表。在这情况下前置的空白行是可有可无的。嵌套列表必须以四
个空白或一个tab 作缩进：

\begin{lstlisting}
* fruits
    + apples
        - macintosh
        - red delicious
    + pears
    + peaches
* vegetables
    + brocolli
    + chard
\end{lstlisting}

上一节提到，markdown
允许你以「偷懒」的方式书写，项目的接续行可以不和第一行对齐。不过，
如果一个列表项目中包含了多个段落或是其他区块元素，那么每个元素的第一行都必须缩进对齐。

\begin{lstlisting}
+ A lazy, lazy, list
item.

+ Another one; this looks
bad but is legal.

    Second paragraph of second
list item.
\end{lstlisting}

\textbf{注意：}尽管针对接续段落的「四个空白规则」是出自于官方的markdown
syntax guide，但是作
为对应参考用的Markdown.pl实作版本中并未遵循此一规则。所以当输入时若接续段落的缩进少于四
个空白时，pandoc所输出的结果会与Markdown.pl的输出有所出入。

在markdown syntax
guide中并未明确表示「四个空白规则」是否一体适用于所有位于列表项目里的
区块元素上；规范文件中只提及了段落与代码区块。但文件暗示了此规则适用于所有区块等级的内容
（包含嵌套列表），并且pandoc以此方向进行解读与实作。

\subsection{有序列表}\label{ux6709ux5e8fux5217ux8868}

有序列表与无序列表相类似，唯一的差别在于列表项目是以列举编号作开头，而不是项目符号。

在原始markdown
中，列举编号是阿拉伯数字后面接着一个句点与空白。数字本身代表的数值会被忽
略，因此下面两个列表并无差别：

\begin{lstlisting}
1.  one
2.  two
3.  three
\end{lstlisting}

上下两个列表的输出是相同的。

\begin{lstlisting}
5.  one
7.  two
1.  three
\end{lstlisting}

\subsubsection{Extension: fancy\_lists}\label{extension-fancy_lists}

与原始markdown不同的是，Pandoc除了使用阿拉伯数字作为有序列表的编号外，也可以使用大写或
小写的英文字母，以及罗马数字。列表标记可以用括号包住，也可以单独一个右括号，抑或是句号。
如果列表标记是大写字母接着一个句号，句号后请使用至少两个空白字元。

\subsubsection{Extension: startnum}\label{extension-startnum}

除了列表标记外，Pandoc
也能判读列表的起始编号，这两项资讯都会保留于输出格式中。举例来说，
下面的输入可以产生一个从编号9
开始，以单括号为编号标记的列表，底下还跟着一个小写罗马数字 的子列表：

\begin{lstlisting}
 9)  Ninth
10)  Tenth
11)  Eleventh
       i. subone
      ii. subtwo
     iii. subthree
\end{lstlisting}

当遇到不同形式的列表标记时，Pandoc
会重新开始一个新的列表。所以，以下的输入会产生三份列表：

\begin{lstlisting}
(2) Two
(5) Three
1.  Four
*   Five
\end{lstlisting}

如果需要预设的有序列表标记符号，可以使用\#.：

\begin{lstlisting}
#.  one
#.  two
#.  three
\end{lstlisting}

\subsection{定义列表}\label{ux5b9aux4e49ux5217ux8868}

\subsubsection{Extension:
definition\_lists}\label{extension-definition_lists}

Pandoc支援定义列表，其语法的灵感来自于PHP Markdown
Extra以及reStructuredText：

\begin{lstlisting}
Term 1

:   Definition 1

Term 2 with *inline markup*

:   Definition 2

        { some code, part of Definition 2 }

    Third paragraph of definition 2.
\end{lstlisting}

每个专有名词(term)
都必须单独存在于一行，后面可以接着一个空白行，也可以省略，但一定
要接上一或多笔定义内容。一笔定义需由一个冒号或波浪线作开头，可以接上一或两个空白作为
缩进。定义本身的内容主体（包括接在冒号或波浪线后的第一行）应该以四个空白缩进。一个专
有名词可以有多个定义，而每个定义可以包含一或多个区块元素（段落、代码区块、列表等），
每个区块元素都要缩进四个空白或一个tab。

如果你在定义内容后面留下空白行（如同上面的范例），那么该段定义会被当作段落处理。在某
些输出格式中，这意谓著成对的专有名词与定义内容间会有较大的空白间距。在定义与定义之间，
以及定义与下个专有名词间不要留空白行，即可产生一个比较紧凑的定义列表：

\begin{lstlisting}
Term 1
  ~ Definition 1
Term 2
  ~ Definition 2a
  ~ Definition 2b
\end{lstlisting}

\subsection{编号范例列表}\label{ux7f16ux53f7ux8303ux4f8bux5217ux8868}

\subsubsection{Extension: example\_lists}\label{extension-example_lists}

这个特别的列表标记@可以用来产生连续编号的范例列表。列表中第一个以@标记的项目
会被编号为'1'，接着编号为'2'，依此类推，直到文件结束。范例项目的编号不会局限
于单一列表中，而是文件中所有以@为标记的项目均会次序递增其编号，直到最后一个。
举例如下：

\begin{lstlisting}
(@)  My first example will be numbered (1).
(@)  My second example will be numbered (2).

Explanation of examples.

(@)  My third example will be numbered (3).
\end{lstlisting}

编号范例可以加上标签，并且在文件的其他地方作参照：

\begin{lstlisting}
(@good)  This is a good example.

As (@good) illustrates, ...
\end{lstlisting}

标签可以是由任何英文字母、底线或是连字符号所组成的字串。

\subsection{紧凑与宽松列表}\label{ux7d27ux51d1ux4e0eux5bbdux677eux5217ux8868}

在与列表相关的「边界处理」上，Pandoc与Markdown.pl有着不同的处理结果。考虑如下代码：

\begin{lstlisting}
+   First
+   Second:
    -   Fee
    -   Fie
    -   Foe

+   Third
\end{lstlisting}

Pandoc会将以上列表转换为「紧凑列表」（在``First'',
``Second''或``Third''之中没有

标签）， 而markdown则会在``Second''与``Third''
（但不包含``First''）里面置入\textless{}p\textgreater{}标签，这是因为``Third''
之前的空白行而造成的结果。Pandoc依循着一个简单规则：如果文字后面跟着空白行，那么就会被
视为段落。既然``Second''后面是跟着一个列表，而非空白行，那么就不会被视为段落了。至于子列
表的后面是不是跟着空白行，那就无关紧要了。（注意：即使是设定为markdown\_strict格式，
Pandoc仍是依以上方式处理列表项目是否为段落的判定。这个处理方式与markdown官方语法规范里
的描述一致，然而却与Markdown.pl的处理不同。）

\subsection{结束一个列表}\label{ux7ed3ux675fux4e00ux4e2aux5217ux8868}

如果你在列表之后放入一个缩排的代码区块，会有什么结果？

\begin{lstlisting}
-   item one
-   item two

    { my code block }
\end{lstlisting}

问题大了！这边pandoc（其他的markdown实作也是如此）会将\{ my code block
\}视为item two这个
列表项目的第二个段落来处理，而不会将其视为一个代码区块。

要在item
two之后「切断」列表，你可以插入一些没有缩排、输出时也不可见的内容，例如HTML的
注解：

\begin{lstlisting}
-   item one
-   item two

<!-- end of list -->

    { my code block }
\end{lstlisting}

当你想要两个各自独立的列表，而非一个大且连续的列表时，也可以运用同样的技巧：

\begin{lstlisting}
1.  one
2.  two
3.  three

<!-- -->

1.  uno
2.  dos
3.  tres
\end{lstlisting}

\section{分隔线}\label{ux5206ux9694ux7ebf}

一行中若包含三个以上的*,
-或\_符号（中间可以以空白字元分隔），则会产生一条分隔线：

\begin{lstlisting}
*  *  *  *

---------------
\end{lstlisting}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\section{表格}\label{ux8868ux683c}

有四种表格的形式可以使用。前三种适用于等宽字型的编辑环境，例如Courier。第四种则
不需要直行的对齐，因此可以在比例字型的环境下使用。

\subsection{简单表格}\label{ux7b80ux5355ux8868ux683c}

\subsubsection{Extension:
simple\_tables,table\_captions}\label{extension-simple_tablestable_captions}

简单表格看起来如表\ref{table:simpletable}所示：

\begin{longtable}[]{@{}rlcl@{}}
\caption{Demonstration of simple table
syntax.\label{table:simpletable}}\tabularnewline
\toprule
Right & Left & Center & Default\tabularnewline
\midrule
\endfirsthead
\toprule
Right & Left & Center & Default\tabularnewline
\midrule
\endhead
12 & 12 & 12 & 12\tabularnewline
123 & 123 & 123 & 123\tabularnewline
1 & 1 & 1 & 1\tabularnewline
\bottomrule
\end{longtable}

代码为：

\begin{lstlisting}
简单表格看起来如表\ref{table:simpletable}所示：

  Right     Left     Center     Default
-------     ------ ----------   -------
     12     12        12            12
    123     123       123          123
      1     1          1             1

Table:  Demonstration of simple table syntax.\label{table:simpletable}
\end{lstlisting}

可以用\lstinline!\label!为表格添加label，然后在其他地方用\lstinline!\ref!引用。

表头与资料列分别以一行为单位。直行的对齐则依照表头的文字和其底下虚线的相对位置来决定：

\begin{itemize}
\tightlist
\item
  如果虚线与表头文字的右侧有切齐，而左侧比表头文字还长，则该直行为靠右对齐。
\item
  如果虚线与表头文字的左侧有切齐，而右侧比表头文字还长，则该直行为靠左对齐。
\item
  如果虚线的两侧都比表头文字长，则该直行为置中对齐。
\item
  如果虚线与表头文字的两侧都有切齐，则会套用预设的对齐方式（在大多数情况下，这将会是靠左对齐）。
\item
  表格底下必须接着一个空白行，或是一行虚线后再一个空白行。表格标题为可选的（上面的范例中有出现）。标题需是一个以Table:（或单纯只有:）开头作为前缀的段落，输出时前缀的这部份会被去除掉。表格标题可以放在表格之前或之后。
\end{itemize}

表头也可以省略，在省略表头的情况下，表格下方必须加上一行虚线以清楚标明表格的范围。例如：

\begin{longtable}[]{@{}rlcr@{}}
\toprule
12 & 12 & 12 & 12\tabularnewline
123 & 123 & 123 & 123\tabularnewline
1 & 1 & 1 & 1\tabularnewline
\bottomrule
\end{longtable}

代码：

\begin{lstlisting}
-------     ------ ----------   -------
     12     12        12             12
    123     123       123           123
      1     1          1              1
-------     ------ ----------   -------
\end{lstlisting}

当省略表头时，直行的对齐会以表格内容的第一行资料列决定。所以，以上面的表格为例，
各直行的对齐依序会是靠右、靠左、置中以及靠右对齐。

\subsection{多行表格}\label{ux591aux884cux8868ux683c}

\subsubsection{Extension:
multiline\_tables,table\_captions}\label{extension-multiline_tablestable_captions}

多行表格允许表头与表格资料格的文字能以多行呈现（但不支援横跨多栏或纵跨多列的
资料格）。以下为范例：

\begin{longtable}[]{@{}clrl@{}}
\caption{Here's the caption. It, too, may span multiple
lines.}\tabularnewline
\toprule
\begin{minipage}[b]{0.15\columnwidth}\centering\strut
Centered Header\strut
\end{minipage} & \begin{minipage}[b]{0.10\columnwidth}\raggedright\strut
Default Aligned\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedleft\strut
Right Aligned\strut
\end{minipage} & \begin{minipage}[b]{0.31\columnwidth}\raggedright\strut
Left Aligned\strut
\end{minipage}\tabularnewline
\midrule
\endfirsthead
\toprule
\begin{minipage}[b]{0.15\columnwidth}\centering\strut
Centered Header\strut
\end{minipage} & \begin{minipage}[b]{0.10\columnwidth}\raggedright\strut
Default Aligned\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedleft\strut
Right Aligned\strut
\end{minipage} & \begin{minipage}[b]{0.31\columnwidth}\raggedright\strut
Left Aligned\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.15\columnwidth}\centering\strut
First\strut
\end{minipage} & \begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
row\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedleft\strut
12.0\strut
\end{minipage} & \begin{minipage}[t]{0.31\columnwidth}\raggedright\strut
Example of a row that spans multiple lines.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.15\columnwidth}\centering\strut
Second\strut
\end{minipage} & \begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
row\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedleft\strut
5.0\strut
\end{minipage} & \begin{minipage}[t]{0.31\columnwidth}\raggedright\strut
Here's another one. Note the blank line between rows.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

代码：

\begin{lstlisting}
-------------------------------------------------------------
 Centered   Default           Right Left
  Header    Aligned         Aligned Aligned
----------- ------- --------------- -------------------------
   First    row                12.0 Example of a row that
                                    spans multiple lines.

  Second    row                 5.0 Here's another one. Note
                                    the blank line between
                                    rows.
-------------------------------------------------------------

Table: Here's the caption. It, too, may span
multiple lines.
\end{lstlisting}

看起来很像简单表格，但两者间有以下差别：

\begin{itemize}
\tightlist
\item
  在表头文字之前，必须以一列虚线作为开头（除非有省略表头）。
\item
  必须以一列虚线作为表格结尾，之后接一个空白行。
\item
  资料列与资料列之间以空白行隔开。
\item
  在多行表格中，表格分析器会计算各直行的栏宽，并在输出时尽可能维持各直行在原始文件中的相对比例。因此，要是你觉得某些栏位在输出时不够宽，你可以在markdown
  的原始档中加宽一点。
\end{itemize}

和简单表格一样，表头在多行表格中也是可以省略的：

\begin{longtable}[]{@{}clrl@{}}
\caption{Here's a multiline table without headers.}\tabularnewline
\toprule
\begin{minipage}[t]{0.15\columnwidth}\centering\strut
First\strut
\end{minipage} & \begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
row\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedleft\strut
12.0\strut
\end{minipage} & \begin{minipage}[t]{0.31\columnwidth}\raggedright\strut
Example of a row that spans multiple lines.\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.15\columnwidth}\centering\strut
Second\strut
\end{minipage} & \begin{minipage}[t]{0.10\columnwidth}\raggedright\strut
row\strut
\end{minipage} & \begin{minipage}[t]{0.20\columnwidth}\raggedleft\strut
5.0\strut
\end{minipage} & \begin{minipage}[t]{0.31\columnwidth}\raggedright\strut
Here's another one. Note the blank line between rows.\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

代码：

\begin{lstlisting}
----------- ------- --------------- -------------------------
   First    row                12.0 Example of a row that
                                    spans multiple lines.

  Second    row                 5.0 Here's another one. Note
                                    the blank line between
                                    rows.
----------- ------- --------------- -------------------------

: Here's a multiline table without headers.
\end{lstlisting}

多行表格中可以单只包含一个资料列，但该资料列之后必须接着一个空白行（然后才是标
示表格结尾的一行虚线）。如果没有此空白行，此表格将会被解读成简单表格。

\subsection{格框表格}\label{ux683cux6846ux8868ux683c}

\subsubsection{Extension:
grid\_tables,table\_captions}\label{extension-grid_tablestable_captions}

格框表格看起来像这样：

\begin{longtable}[]{@{}lll@{}}
\caption{Sample grid table.}\tabularnewline
\toprule
\begin{minipage}[b]{0.20\columnwidth}\raggedright\strut
Fruit\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedright\strut
Price\strut
\end{minipage} & \begin{minipage}[b]{0.27\columnwidth}\raggedright\strut
Advantages\strut
\end{minipage}\tabularnewline
\midrule
\endfirsthead
\toprule
\begin{minipage}[b]{0.20\columnwidth}\raggedright\strut
Fruit\strut
\end{minipage} & \begin{minipage}[b]{0.20\columnwidth}\raggedright\strut
Price\strut
\end{minipage} & \begin{minipage}[b]{0.27\columnwidth}\raggedright\strut
Advantages\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.32\columnwidth}\raggedright\strut
Bananas\strut
\end{minipage} & \begin{minipage}[t]{0.32\columnwidth}\raggedright\strut
\$1.34\strut
\end{minipage} & \begin{minipage}[t]{0.32\columnwidth}\raggedright\strut
\begin{itemize}
\tightlist
\item
  built-in wrapper
\item
  bright color
\end{itemize}\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.32\columnwidth}\raggedright\strut
Oranges\strut
\end{minipage} & \begin{minipage}[t]{0.32\columnwidth}\raggedright\strut
\$2.10\strut
\end{minipage} & \begin{minipage}[t]{0.32\columnwidth}\raggedright\strut
\begin{itemize}
\tightlist
\item
  cures scurvy
\item
  tasty
\end{itemize}\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

代码：

\begin{lstlisting}
: Sample grid table.

+---------------+---------------+--------------------+
| Fruit         | Price         | Advantages         |
+===============+===============+====================+
| Bananas       | $1.34         | - built-in wrapper |
|               |               | - bright color     |
+---------------+---------------+--------------------+
| Oranges       | $2.10         | - cures scurvy     |
|               |               | - tasty            |
+---------------+---------------+--------------------+
\end{lstlisting}

以=串成的一行区分了表头与表格本体，这在没有表头的表格中也是可以省略的。在格框表格中
的资料格可以包含任意的区块元素（复数段落、代码区块、清单等等）。不支援对齐，也不支
援横跨多栏或纵跨多列的资料格。格框表格可以在Emacs table mode下轻松建立。

\subsection{管线表格}\label{ux7ba1ux7ebfux8868ux683c}

\subsubsection{Extension:
pipe\_tables,table\_captions}\label{extension-pipe_tablestable_captions}

管线表格看起来像这样：

\begin{longtable}[]{@{}rllc@{}}
\caption{Demonstration of simple table syntax.}\tabularnewline
\toprule
Right & Left & Default & Center\tabularnewline
\midrule
\endfirsthead
\toprule
Right & Left & Default & Center\tabularnewline
\midrule
\endhead
12 & 12 & 12 & 12\tabularnewline
123 & 123 & 123 & 123\tabularnewline
1 & 1 & 1 & 1\tabularnewline
\bottomrule
\end{longtable}

代码：

\begin{lstlisting}
| Right | Left | Default | Center |
|------:|:-----|---------|:------:|
|   12  |  12  |    12   |    12  |
|  123  |  123 |   123   |   123  |
|    1  |    1 |     1   |     1  |

  : Demonstration of simple table syntax.
\end{lstlisting}

这个语法与PHP markdown
extra中的表格语法相同。开始与结尾的管线字元是可选的，但各直行间
则必须以管线区隔。上面范例中的冒号表明了对齐方式。表头可以省略，但表头下的水平虚线必须
保留，因为虚线上定义了资料栏的对齐方式。

因为管线界定了各栏之间的边界，表格的原始码并不需要像上面例子中各栏之间保持直行对齐。所
以，底下一样是个完全合法（虽然丑陋）的管线表格：

\begin{lstlisting}
fruit| price
-----|-----:
apple|2.05
pear|1.37
orange|3.09
\end{lstlisting}

管线表格的资料格不能包含如段落、清单之类的区块元素，也不能包含多行文字。

注意：Pandoc 也可以看得懂以下形式的管线表格，这是由Emacs 的orgtbl-mod
所绘制：

\begin{lstlisting}
| One | Two   |
|-----+-------|
| my  | table |
| is  | nice  |
\end{lstlisting}

效果：

\begin{longtable}[]{@{}ll@{}}
\toprule
One & Two\tabularnewline
\midrule
\endhead
my & table\tabularnewline
is & nice\tabularnewline
\bottomrule
\end{longtable}

主要的差别在于以+取代了部分的\textbar{}。其他的orgtbl功能并未支援。如果要指定非预设的直
行对齐形式，你仍然需要在上面的表格中自行加入冒号。

\section{文件标题区块}\label{ux6587ux4ef6ux6807ux9898ux533aux5757}

（译注：本节中提到的「标题」均指Title，而非Headers）

\subsubsection{Extension:
pandoc\_title\_block}\label{extension-pandoc_title_block}

如果档案以文件标题（Title）区块开头

\begin{lstlisting}
% title
% author(s) (separated by semicolons)
% date
\end{lstlisting}

这部份将不会作为一般文字处理，而会以书目资讯的方式解析。（这可用在像是单
一LaTeX 或是HTML 输出文件的书名上。）这个区块仅能包含标题，或是标题与作
者，或是标题、作者与日期。如果你只想包含作者却不想包含标题，或是只有标题
与日期而没有作者，你得利用空白行：

\begin{lstlisting}
%
% Author

% My title
%
% June 15, 2006
\end{lstlisting}

标题可以包含多行文字，但接续行必须以空白字元开头，像是：

\begin{lstlisting}
% My title
  on multiple lines
\end{lstlisting}

如果文件有多个作者，作者也可以分列在不同行并以空白字元作开头，或是以分号间隔，或
是两者并行。所以，下列各种写法得到的结果都是相同的：

\begin{lstlisting}
% Author One
  Author Two

% Author One; Author Two

% Author One;
  Author Two
\end{lstlisting}

日期就只能写在一行之内。

所有这三个metadata
栏位都可以包含标准的行内格式（斜体、连结、脚注等等）。

文件标题区块一定会被分析处理，但只有在\lstinline!--standaline( -s)!选项被设定时才会影响输出内
容。在输出HTML时，文件标题会出现的地方有两个：一个是在文件的\lstinline!<head>!区块里---这会
显示在浏览器的视窗标题上---另外一个是文件的\lstinline!<body>!区块最前面。位于\lstinline!<head>!里的文件
标题可以选择性地加上前缀文字（透过\lstinline!--title-prefix!或\lstinline!-T!选项）。而在\lstinline!<body>!里的文件标
题会以H1元素呈现，并附带``title''类别(class)，这样就能藉由CSS来隐藏显示或重新定义格
式。如果以-T选项指定了标题前缀文字，却没有设定文件标题区块里的标题，那么前缀文字本
身就会被当作是HTML的文件标题。

而man page的输出器会分析文件标题区块的标题行，以解出标题、man page
section number，
以及其他页眉(header)页脚(footer)所需要的资讯。一般会假设标题行的第一个单字为标题，
标题后也许会紧接着一个以括号包住的单一数字，代表section
number（标题与括号之间没
有空白）。在此之后的其他文字则为页脚与页眉文字。页脚与页眉文字之间是以单独的一个
管线符号( \textbar{})作为区隔。所以，

\begin{lstlisting}
% PANDOC(1)
\end{lstlisting}

将会产生一份标题为PANDOC且section为1的man page。

\begin{lstlisting}
% PANDOC(1) Pandoc User Manuals
\end{lstlisting}

产生的man page 会再加上``Pandoc User Manuals'' 在页脚处。

\begin{lstlisting}
% PANDOC(1) Pandoc User Manuals | Version 4.0
\end{lstlisting}

产生的man page 会再加上``Version 4.0'' 在页眉处。

\section{字符转义}\label{ux5b57ux7b26ux8f6cux4e49}

\subsubsection{Extension:
all\_symbols\_escapable}\label{extension-all_symbols_escapable}

除了在代码区块或行内代码之外，任何标点符号或空白字元前面只要加上一个
反斜线，都能使其保留字面原义，而不会进行格式的转义解读。因此，举例来
说，下面的写法

\begin{lstlisting}
*\*hello\**
\end{lstlisting}

输出后会得到

\begin{lstlisting}
<em>*hello*</em>
\end{lstlisting}

而不是

\begin{lstlisting}
<strong>hello</strong>
\end{lstlisting}

这条规则比原始的markdown
规则来得好记许多，原始规则中，只有以下字元才支持
反斜线跳脱，不作进一步转义：

\begin{lstlisting}
\`*_{}[]()>#+-.!
\end{lstlisting}

（然而，如果使用了markdown\_strict格式，那么就会采用原始的markdown规则）

一个反斜线之后的空白字元会被解释为不断行的空白(nonbreaking
space)。这在TeX的
输出中会显示为\lstinline!~!，而在HTML与XML则是显示为\lstinline!\&#160;!或\lstinline!\&nbsp;!。

一个反斜线之后的换行字元（例如反斜线符号出现在一行的最尾端）则会被解释为强制
换行。这在TeX的输出中会显示为\lstinline!\\!，而在HTML里则是\lstinline!<br />!。相对于原始markdown是以
在行尾加上两个空白字元这种「看不见」的方式进行强制换行，反斜线接换行字元会是比较好
的替代方案。

转义字符在代码上下文中不起任何作用。

\section{智能标点}\label{ux667aux80fdux6807ux70b9}

如果指定了\lstinline!--smart!选项，pandoc将会输出正式印刷用的标点符号，像是将\lstinline!straight quotes!转
换为\lstinline!curly quotes! \footnote{译注：straight
  quotes指的是左右两侧都长得一样的引号，例如我们直接在键盘上打出来的
  单引号或双引号；curly
  quotes则是左右两侧不同，有从两侧向内包夹视觉效果的引号。}、\lstinline!---!转为破折号(em-dashes)，\lstinline!--!转为连接号(en-dashes)，以及将
\lstinline!...!转为省略号。不断行空格(Nonbreaking
spaces)将会插入某些缩写词之后，例如``Mr.''。

注意：如果你的LaTeX
template使用了csquotes套件，pandoc会自动侦测并且使用\lstinline!\enquote{...}!
在引言文字上。

\section{行内格式}\label{ux884cux5185ux683cux5f0f}

\subsection{强调}\label{ux5f3aux8c03}

要强调某些文字，只要以\lstinline!*!或\lstinline!_!符号前后包住即可，像这样：

\begin{lstlisting}
This text is _emphasized with underscores_, and this
is *emphasized with asterisks*.
\end{lstlisting}

重复两个\lstinline!*!或\lstinline!_!符号以产生更强烈的强调：

\begin{lstlisting}
This is **strong emphasis** and __with underscores__.
\end{lstlisting}

This is \textbf{strong emphasis} and \textbf{with underscores}.

一个前后以空白字元包住，或是前面加上反斜线的\lstinline!*!或\lstinline!_!符号，都不会转换为强调格式：

\begin{lstlisting}
This is * not emphasized *, and \*neither is this\*.
\end{lstlisting}

\subsubsection{Extension:
intraword\_underscores}\label{extension-intraword_underscores}

因为\_字元有时会使用在单字或是ID之中，所以pandoc不会把被字母包住的\_解读为强调标记。
如果有需要特别强调单字中的一部分，就用*：

\begin{lstlisting}
feas*ible*, not feas*able*.
\end{lstlisting}

\subsection{删除线}\label{ux5220ux9664ux7ebf}

\subsubsection{Extension: strikeout}\label{extension-strikeout}

要将一段文字加上水平线作为删除效果，将该段文字前后以\lstinline!~~!包住即可。例如，

\begin{lstlisting}
This ~~is deleted text.~~
\end{lstlisting}

\subsection{上标与下标}\label{ux4e0aux6807ux4e0eux4e0bux6807}

\subsubsection{Extension:
superscript,subscript}\label{extension-superscriptsubscript}

要输入上标可以用\lstinline!^!字元将要上标的文字包起来；要输入下标可以用\lstinline!~!字元将要下标的
文字包起来。直接看范例，

\begin{lstlisting}
H~2~O is a liquid.  2^10^ is 1024.
\end{lstlisting}

H\textsubscript{2}O is a liquid. 2\textsuperscript{10} is 1024.

如果要上标或下标的文字中包含了空白，那么这个空白字元之前必须加上反斜线。（这是为
了避免一般使用下的\lstinline!~!和\lstinline!^!在非预期的情况下产生出意外的上标或下标。）所以，如果你想要
让字母P后面跟着下标文字'a
cat'，那么就要输入\lstinline!P~a\ cat~!，而不是\lstinline!P~a cat~!。

\subsection{字面文字}\label{ux5b57ux9762ux6587ux5b57}

要让一小段文字直接以其字面形式呈现，可以用反引号将其包住：

\begin{lstlisting}
What is the difference between `>>=` and `>>`?
\end{lstlisting}

如果字面文字中也包含了反引号，那就使用双重反引号包住：

\begin{lstlisting}
Here is a literal backtick `` ` ``.
\end{lstlisting}

（在起始反引号后的空白以及结束反引号前的空白都会被忽略。）

一般性的规则如下，字面文字区段是以连续的反引号字元作为开始（反引号后的空白字元为可选），
一直到同样数目的反引号字元出现才结束（反引号前的空白字元也为可选）。

要注意的是，转义字符（以及其他markdown
结构）在字面文字的上下文中是没有效果的：

\begin{lstlisting}
This is a backslash followed by an asterisk: `\*`.
\end{lstlisting}

\subsubsection{Extension:
inline\_code\_attributes}\label{extension-inline_code_attributes}

与围栏代码区块一样，字面文字也可以附加属性：

\begin{lstlisting}
`<$>`{.haskell}
\end{lstlisting}

\section{数学}\label{ux6570ux5b66}

\subsubsection{Extension:
tex\_math\_dollars}\label{extension-tex_math_dollars}

所有介于两个\lstinline!$!字元之间的内容将会被视为TeX数学公式处理。开头的\lstinline!$!右侧必须立刻接上任意文
字，而结尾\lstinline!$!的左侧同样也必须紧挨着文字。这样一来，\lstinline!$20,000  and  $30,000!就不会被当作数学公
式处理了。如果基于某些原因，有必须使用\lstinline!$!符号将其他文字括住的需求时，那么可以在\lstinline!$!前使用反
斜线跳脱字元，这样\lstinline!$!就不会被当作数学公式的分隔符。

TeX 数学公式会在所有输出格式中印出。至于会以什么方式演算编排(render)
则取决于输出的格式：

\subsubsection{Markdown, LaTeX, Org-Mode,
ConTeXt}\label{markdown-latex-org-mode-context}

公式会以字面文字呈现在两个\$符号之间。

\subsubsection{reStructuredText}\label{restructuredtext}

公式会使用此处所描述的:math:这个``interpreted text
role''来进行演算编排。

\subsubsection{AsciiDoc}\label{asciidoc}

公式会以latexmath:{[}\ldots{}{]}演算编排。

\subsubsection{Texinfo}\label{texinfo}

公式会在@math指令中演算编排。

\subsubsection{groff man}\label{groff-man}

公式会以去掉\lstinline!$!后的字面文字演算编排。

\subsubsection{MediaWiki}\label{mediawiki}

公式会在标签中演算编排。

\subsubsection{Textile}\label{textile}

公式会在\lstinline!<span class="math">!标签中演算编排。

\subsubsection{RTF, OpenDocument, ODT}\label{rtf-opendocument-odt}

如果可以的话，公式会以unicode 字元演算编排，不然就直接使用字面字元。

\subsubsection{Docbook}\label{docbook}

如果使用了\lstinline!--mathml!旗标，公式就会在inlineequation或informalequation标签中
使用mathml演算编排。否则就会尽可能使用unicode字元演算编排。

\subsubsection{Docx}\label{docx}

公式会以OMML 数学标记的方式演算编排。

\subsubsection{FictionBook2}\label{fictionbook2}

如果有使用\lstinline!--webtex!选项，公式会以Google
Charts或其他相容的网路服务演算编排为
图片，并下载嵌入于电子书中。否则就会以字面文字显示。

\subsubsection{HTML, Slidy, DZSlides, S5,
EPUB}\label{html-slidy-dzslides-s5-epub}

公式会依照以下命令列选项的设置，以不同的方法演算编排为HTML 代码。

预设方式是将TeX数学公式尽可能地以unicode字元演算编排，如同RTF、DocBook以及OpenDocument的
输出。公式会被放在附有属性\lstinline!class="math"!的span标签内，所以可以在需要时给予不同的样式，使其
突出于周遭的文字内容。

如果使用了\lstinline!--latexmathml!选项，TeX数学公式会被显示于\lstinline!$!或\lstinline!$$!字元中，并放在附带LaTeX类别
的\lstinline!<span>!标签里。这段内容会用LaTeXMathML
script演算编排为数学公式。（这个方法无法适用于
所有浏览器，但在Firefox中是有效的。在不支援LaTeXMathML的浏览器中，TeX数学公式会单纯的以
两个\$字元间的字面文字呈现。）

如果使用了\lstinline!--jsmath!选项，TeX数学公式会放在\lstinline!<span>!标签（用于行内数学公式）或\lstinline!<div>!标签
（用于区块数学公式）中，并附带类别属性math。这段内容会使用jsMath
script来演算编排。

如果使用了\lstinline!--mimetex!选项，mimeTeX CGI
script会被呼叫来产生每个TeX数学公式的图片。这适用
于所有浏览器。\lstinline!--mimetex!选项有一个可选的URL参数。如果没有指定URL，它会假设mimeTeX
CGI script的位置在\lstinline!/cgi-bin/mimetex.cig!。

如果使用了\lstinline!--gladtex!选项，TeX数学公式在HTML的输出中会被\lstinline!<eq>!标签包住。产生的htex档案之
后可以透过gladTeX处理，这会针对每个数学公式生成图片，并于最后生成一个包含这些图片连结的html
档案。所以，整个处理流程如下：

\begin{lstlisting}
pandoc -s --gladtex myfile.txt -o myfile.htex
gladtex -d myfile-images myfile.htex
# produces myfile.html and images in myfile-images
\end{lstlisting}

如果使用了\lstinline!--webtex!选项，TeX数学公式会被转换为\lstinline!<img>!标签并连结到一个用以转换公式为图片的
外部script。公式将会编码为URL可接受格式并且与指定的URL参数串接。如果没有指定URL，那么将会
使用Google Chart API (
http://chart.apis.google.com/chart?cht=tx\&chl=)。

如果使用了\lstinline!--mathjax!选项，TeX数学公式将会被包在\lstinline!\(...\)!（用于行内数学公式）或\lstinline!\[...\]!（用
于区块数学公式）之间显示，并且放在附带类别math的\lstinline!<span>!标签之中。这段内容会使用MathJax
script 演算编排为页面上的数学公式。

\section{Raw HTML}\label{raw-html}

\subsubsection{Extension: raw\_html}\label{extension-raw_html}

Markdown允许你在文件中的任何地方插入原始HTML（或DocBook）指令（除了在字面文字上下文处，
此时的\lstinline!<!,
\lstinline!>!和\&都会按其字面意义显示）。（技术上而言这不算扩充功能，因为原始markdown本身就
有提供此功能，但做成扩充形式便可以在有特殊需要的时候关闭此功能。）

输出HTML, S5, Slidy, Slideous, DZSlides, EPUB, Markdown 以及Textile
等格式时，原始HTML 代
码会不作修改地保留至输出档案中；而其他格式的输出内容则会将原始HTML
代码去除掉。

\subsubsection{Extension:
markdown\_in\_html\_blocks}\label{extension-markdown_in_html_blocks}

原始markdown允许你插入HTML「区块」：所谓的HTML区块是指，上下各由一个空白行所隔开，开始与结尾
均由所在行最左侧开始的一连串对称均衡的HTML标签。在这个区块中，任何内容都会当作是HTML来分析，
而不再视为markdown；所以（举例来说），*符号就不再代表强调。

当指定格式为markdown\_strict时，Pandoc会以上述方式处理；但预设情况下，Pandoc能够以markdown语法
解读HTML区块标签中的内容。举例说明，Pandoc能够将底下这段

\begin{lstlisting}
<table>
    <tr>
        <td>*one*</td>
        <td>[a link](http://google.com)</td>
    </tr>
</table>
\end{lstlisting}

转换为

\begin{lstlisting}
<table>
    <tr>
        <td><em>one</em></td>
        <td><a href="http://google.com">a link</a></td>
    </tr>
</table>
\end{lstlisting}

而Markdown.pl则是保留该段原样。

这个规则只有一个例外：那就是介于\lstinline!<script>!与\lstinline!<style>!之间的文字都不会被拿来当作markdown解读。

这边与原始markdown的分歧，主要是为了让markdown能够更便利地混入HTML区块元素。比方说，一段
markdown文字可以用\lstinline!<div>!标签将其前后包住来进行样式指定，而不用担心里面的markdown不会被解
译到。

\section{Raw TeX}\label{raw-tex}

\subsubsection{Extension: raw\_tex}\label{extension-raw_tex}

除了HTML 之外，pandoc 也接受文件中嵌入原始LaTeX, TeX 以及ConTeXt
代码。行内TeX 指令会被保留 并不作修改地输出至LaTeX 与ConTeXt
格式中。所以，举例来说，你可以使用LaTeX 来导入BibTeX 的引 用文献：

\begin{lstlisting}
This result was proved in \cite{jones.1967}.
\end{lstlisting}

请注意在LaTeX 环境下时，像是底下

\begin{lstlisting}
\begin{tabular}{|l|l|}\hline
Age & Frequency \\ \hline
18--25  & 15 \\
26--35  & 33 \\
36--45  & 22 \\ \hline
\end{tabular}
\end{lstlisting}

位在begin与end标签之间的内容，都会被当作是原始LaTeX资料解读，而不会视为markdown。

行内LaTeX 在输出至Markdown, LaTeX 及ConTeXt 之外的格式时会被忽略掉。

\section{LaTeX 巨集}\label{latex-ux5de8ux96c6}

\subsubsection{Extension: latex\_macros}\label{extension-latex_macros}

当输出格式不是LaTeX时，pandoc会分析LaTeX的\lstinline!\newcommand!和\lstinline!\renewcommand!定义，并套用
其产生的巨集到所有LaTeX数学公式中。所以，举例来说，下列指令对于所有的输出格式均有作
用，而非仅仅作用于LaTeX格式：

\begin{lstlisting}
\newcommand{\tuple}[1]{\langle #1 \rangle}

$\tuple{a, b, c}$
\end{lstlisting}

在LaTeX的输出中，\lstinline!\newcommand!定义会单纯不作修改地保留至输出结果。

\section{连结}\label{ux8fdeux7ed3}

Markdown 接受以下数种指定连结的方式。

\subsection{自动连结}\label{ux81eaux52a8ux8fdeux7ed3}

如果你用角括号将一段URL 或是email 位址包起来，它会自动转换成连结：

\url{http://google.com}

\href{mailto:sam@green.eggs.ham}{\nolinkurl{sam@green.eggs.ham}}

\subsection{行内连结}\label{ux884cux5185ux8fdeux7ed3}

一个行内连结包含了位在方括号中的连结文字，以及方括号后以圆括号包起来的URL。（你可以选
择性地在URL 后面加入连结标题，标题文字要放在引号之中。）

\begin{lstlisting}
This is an [inline link](/url), and here's [one with
a title](http://fsf.org "click here for a good time!").
\end{lstlisting}

This is an \href{/url}{inline link}, and here's
\href{http://fsf.org}{one with a title}.

方括号与圆括号之间不能有空白。连结文字可以包含格式（例如强调），但连结标题则否。

\subsection{参考连结}\label{ux53c2ux8003ux8fdeux7ed3}

一个明确的参考连结包含两个部分，连结本身以及连结定义，其中连结定义可以放在文件的任何地
方（不论是放在连结所在处之前或之后）。

连结本身是由两组方括号所组成，第一组方括号中为连结文字，第二组为连结标签。（在两个方括号
间可以有空白。）连结定义则是以方括号框住的连结标签作开头，后面跟着一个冒号一个空白，再接
着一个URL，最后可以选择性地（在一个空白之后）加入由引号或是圆括号包住的连结标题。

以下是一些范例：

\begin{lstlisting}
[my label 1]: /foo/bar.html  "My title, optional"
[my label 2]: /foo
[my label 3]: http://fsf.org (The free software foundation)
[my label 4]: /bar#special  'A title in single quotes'
\end{lstlisting}

连结的URL 也可以选择性地以角括号包住：

\begin{lstlisting}
[my label 5]: <http://foo.bar.baz>
\end{lstlisting}

连结标题可以放在第二行，效果见\href{http://fsf.org}{my label 3}：

\begin{lstlisting}
[my label 3]: http://fsf.org
  "The free software foundation"
\end{lstlisting}

需注意连结标签并不区分大小写。所以下面的例子会建立合法的连结：

\begin{lstlisting}
Here is [my link][FOO]

[Foo]: /bar/baz
\end{lstlisting}

在一个隐性参考连结中，第二组方括号的内容是空的，甚至可以完全地略去：

\begin{lstlisting}
See [my website][], or [my website].

[my website]: http://foo.bar.baz
\end{lstlisting}

注意：在Markdown.pl以及大多数其他markdown实作中，参考连结的定义不能存在于嵌套结构中，例
如清单项目或是区块引言。Pandoc lifts this arbitrary seeming
restriction。所以虽然下面的
语法在几乎所有其他实作中都是错误的，但在pandoc中可以正确处理：

\begin{lstlisting}
> My block [quote].
>
> [quote]: /foo
\end{lstlisting}

\subsection{内部连结}\label{ux5185ux90e8ux8fdeux7ed3}

要连结到同一份文件的其他章节，可使用自动产生的ID（参见HTML,
LaTeX与ConTeXt的标题识别符一 节后半）。

\begin{lstlisting}
See the [Introduction](#introduction).
\end{lstlisting}

或是

\begin{lstlisting}
See the [Introduction].

[Introduction]: #introduction
\end{lstlisting}

内部连结目前支援的格式有HTML（包括HTML slide shows 与EPUB）、LaTeX
以及ConTeXt。

\section{图片}\label{ux56feux7247}

在连结语法的前面加上一个!就是图片的语法了。连结文字将会作为图片的替代文字（alt
text）：

\begin{lstlisting}
![la lune](Pictures/background.pdf "Voyage to the moon")

![movie reel]

[movie reel]: movie.gif
\end{lstlisting}

也可以使用LaTeX的\lstinline!\label!为图片添加label，这样就可以在其他地方引用了，例如：

\begin{lstlisting}
效果如图\ref{fig:markdown}。

![Markdown\label{fig:markdown}](images/markdown.jpg "Markdown")
\end{lstlisting}

效果如图\ref{fig:markdown}。

\begin{figure}
\centering
\includegraphics{images/markdown.jpg}
\caption{Markdown\label{fig:markdown}}
\end{figure}

\subsection{附上说明的图片}\label{ux9644ux4e0aux8bf4ux660eux7684ux56feux7247}

\subsubsection{Extension:
implicit\_figures}\label{extension-implicit_figures}

一个图片若自身单独存在一个段落中，那么将会以附上图片说明(caption)的图表(figure)形式呈
现。（在LaTeX中，会使用图表环境；在HTML中，图片会被放在具有figure类别的div元素中，并会附
上一个具有caption类别的p元素。）图片的替代文字同时也会用来作为图片说明。

\begin{lstlisting}
![This is the caption](/url/of/image.png)
\end{lstlisting}

如果你只是想要个一般的行内图片，那么只要让图片不是段落里唯一的元素即可。一个简单的方法
是在图片后面插入一个不断行空格：

\begin{lstlisting}
![This image won't be a figure](/url/of/image.png)\
\end{lstlisting}

\section{脚注}\label{ux811aux6ce8}

\subsubsection{Extension: footnotes}\label{extension-footnotes}

Pandoc's markdown
支援脚注功能，使用如代码\ref{code:footnote}所示的语法：

\begin{lstlisting}[caption=脚注语法, label=code:footnote, float=htbp]
Here is a footnote reference,[^1] and another.[^longnote]

[^1]: Here is the footnote.

[^longnote]: Here's one with multiple blocks.

    Subsequent paragraphs are indented to show that they
belong to the previous footnote.

        { some.code }

    The whole paragraph can be indented, or just the first
    line.  In this way, multi-paragraph footnotes work like
    multi-paragraph list items.

This paragraph won't be part of the note, because it
isn't indented.
\end{lstlisting}

Here is a footnote reference,\footnote{Here is the footnote.} and
another.\footnote{Here's one with multiple blocks.

  Subsequent paragraphs are indented to show that they belong to the
  previous footnote.

  \{ some.code \}

  The whole paragraph can be indented, or just the first line. In this
  way, multi-paragraph footnotes work like multi-paragraph list items.}

This paragraph won't be part of the note, because it isn't indented.

脚注参考用的ID 不得包含空白、tabs 或换行字元。这些ID
只会用来建立脚注位置与脚注文字的
对应关连；在输出时，脚注将会依序递增编号。

脚注本身不需要放在文件的最后面。它们可以放在文件里的任何地方，但不能被放入区块元素（清
单、区块引言、表格等）之中。

\subsubsection{Extension: inline\_notes}\label{extension-inline_notes}

Pandoc
也支援了行内脚注（尽管，与一般脚注不同，行内脚注不能包含多个段落）。其语法如下：

\begin{lstlisting}
Here is an inline note.^[Inlines notes are easier to write, since
you don't have to pick an identifier and move down to type the
note.]
\end{lstlisting}

Here is an inline note.\footnote{Inlines notes are easier to write,
  since you don't have to pick an identifier and move down to type the
  note.}

行内与一般脚注可以自由交错使用。

\section{引用}\label{ux5f15ux7528-1}

\subsubsection{Extension: citations}\label{extension-citations}

Pandoc能够以数种形式自动产生引用与参考书目（使用Andrea
Rossato的hs-citeproc）。为了使用这
项功能，你需要一个下列其中一种格式的参考书目资料库，如表\ref{table:citations}所示：

\begin{longtable}[]{@{}rr@{}}
\caption{\label{table:citations}Pandoc支持的引用形式}\tabularnewline
\toprule
Format & File extension\tabularnewline
\midrule
\endfirsthead
\toprule
Format & File extension\tabularnewline
\midrule
\endhead
MODS & .mods\tabularnewline
BibLaTeX & .bib\tabularnewline
BibTeX & .bibtex\tabularnewline
RIS & .ris\tabularnewline
EndNote & .enl\tabularnewline
EndNote XML & .xml\tabularnewline
ISI & .wos\tabularnewline
MEDLINE & .medline\tabularnewline
Copac & .copac\tabularnewline
JSON citeproc & .json\tabularnewline
\bottomrule
\end{longtable}

需注意的是副档名.bib一般而言同时适用于BibTeX与BibLaTeX的档案，不过你可以使用.bibtex来强制
指定BibTeX。

你需要使用命令列选项\lstinline!--bibliography!来指定参考书目档案（如果有多个书目档就得反覆指定）。

预设情况下，pandoc会在引用文献与参考书目中使用芝加哥「作者－日期」格式。要使用其他的格式，
你需要用\lstinline!--csl!选项来指定一个CSL
1.0格式的档案。关于建立与修改CSL格式的入门可以
在http://citationstyles.org/downloads/primer.html这边找到。
https://github.com/citation-style-language/styles是CSL格式的档案库。
也可以在http://zotero.org/styles以简单的方式浏览。

引用资讯放在方括号中，以分号区隔。每一条引用都会有个key，由@加上资料库中的引用ID组成，并
且可以选择性地包含前缀、定位以及后缀。以下是一些范例：

\begin{lstlisting}
Blah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].

Blah blah [@doe99, pp. 33-35, 38-39 and *passim*].

Blah blah [@smith04; @doe99].
\end{lstlisting}

在@前面的减号(
-)将会避免作者名字在引用中出现。这可以用在已经提及作者的文章场合中：

\begin{lstlisting}
Smith says blah [-@smith04].
\end{lstlisting}

你也可以在文字中直接插入引用资讯，方式如下：

\begin{lstlisting}
@smith04 says blah.

@smith04 [p. 33] says blah.
\end{lstlisting}

如果引用格式档需要产生一份引用作品的清单，这份清单会被放在文件的最后面。一般而言，
你需要以一个适当的标题结束你的文件：

\begin{lstlisting}
last paragraph...

# References
\end{lstlisting}

如此一来参考书目就会被放在这个标题后面了。

\backmatter

\end{document}
